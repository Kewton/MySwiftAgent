name: "üè∑Ô∏è Automatic Release and Tagging"

on:
  push:
    branches: [main]
    paths-ignore:
      - 'docs/**'
      - '**.md'
      - '.github/workflows/**'
  workflow_dispatch:

env:
  REGISTRY: ghcr.io

jobs:
  detect-changes:
    name: Detect Project Changes
    runs-on: ubuntu-latest
    outputs:
      changed_projects: ${{ steps.changes.outputs.projects }}
      changed_projects_json: ${{ steps.changes.outputs.projects_json }}
      has_changes: ${{ steps.changes.outputs.has_changes }}
      is_multi_project: ${{ steps.changes.outputs.is_multi_project }}

    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          token: ${{ secrets.GITHUB_TOKEN }}

      - name: Detect changed projects
        id: changes
        run: |
          echo "üîç Detecting changed projects in this merge..."

          CHANGED_PROJECTS=""
          HAS_CHANGES="false"
          PROJECT_COUNT=0

          for project in myscheduler jobqueue docs commonUI expertAgent; do
            if [[ -d "$project" ]]; then
              CHANGES=$(git diff HEAD~1 HEAD --name-only | grep "^$project/" || true)
              if [[ -n "$CHANGES" ]]; then
                echo "üì¶ Changes detected in $project"

                if [[ -z "$CHANGED_PROJECTS" ]]; then
                  CHANGED_PROJECTS="$project"
                else
                  CHANGED_PROJECTS="$CHANGED_PROJECTS,$project"
                fi
                HAS_CHANGES="true"
                PROJECT_COUNT=$((PROJECT_COUNT + 1))
              fi
            fi
          done

          # Convert to JSON array
          if [[ -n "$CHANGED_PROJECTS" ]]; then
            IFS=',' read -ra PROJECT_ARRAY <<< "$CHANGED_PROJECTS"
            PROJECTS_JSON="["
            for i in "${!PROJECT_ARRAY[@]}"; do
              if [[ $i -gt 0 ]]; then
                PROJECTS_JSON+=","
              fi
              PROJECTS_JSON+="\"${PROJECT_ARRAY[$i]}\""
            done
            PROJECTS_JSON+="]"
          else
            PROJECTS_JSON="[]"
          fi

          # Determine if multi-project release
          if [[ $PROJECT_COUNT -gt 1 ]]; then
            IS_MULTI_PROJECT="true"
          else
            IS_MULTI_PROJECT="false"
          fi

          echo "projects=$CHANGED_PROJECTS" >> $GITHUB_OUTPUT
          echo "projects_json=$PROJECTS_JSON" >> $GITHUB_OUTPUT
          echo "has_changes=$HAS_CHANGES" >> $GITHUB_OUTPUT
          echo "is_multi_project=$IS_MULTI_PROJECT" >> $GITHUB_OUTPUT

          if [[ "$HAS_CHANGES" == "true" ]]; then
            echo "‚úÖ Changed projects: $CHANGED_PROJECTS (count: $PROJECT_COUNT)"
            echo "üìã Multi-project release: $IS_MULTI_PROJECT"
          else
            echo "‚ÑπÔ∏è No project changes detected in this merge"
          fi

  create-releases:
    name: Create Releases and Tags
    runs-on: ubuntu-latest
    needs: [detect-changes]
    if: needs.detect-changes.outputs.has_changes == 'true'

    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          token: ${{ secrets.GITHUB_TOKEN }}

      - name: Process changed projects
        run: |
          # Get current date in YYYY.MM.DD format
          RELEASE_DATE=$(date +%Y.%m.%d)

          # Function to get next sequential number for the current date
          get_next_sequence() {
            local date_pattern="$1"
            # Fetch all tags from remote
            git fetch --tags
            # Find all tags matching the date pattern and extract sequence numbers
            local max_seq=$(git tag -l "${date_pattern}.*/*" | \
              sed -n "s|^${date_pattern}\.\([0-9]\{2\}\)/.*|\1|p" | \
              sort -n | tail -1)

            if [[ -z "$max_seq" ]]; then
              echo "01"
            else
              printf "%02d" $((10#$max_seq + 1))
            fi
          }

          git config --global user.name "github-actions[bot]"
          git config --global user.email "github-actions[bot]@users.noreply.github.com"

          IFS=',' read -ra PROJECTS <<< "${{ needs.detect-changes.outputs.changed_projects }}"

          for project in "${PROJECTS[@]}"; do
            echo "üöÄ Processing project: $project"

            if [[ ! -d "$project" ]]; then
              echo "‚ö†Ô∏è Project directory $project does not exist, skipping"
              continue
            fi

            if [[ ! -f "$project/pyproject.toml" ]]; then
              echo "‚ö†Ô∏è pyproject.toml not found in $project, skipping"
              continue
            fi

            VERSION=$(grep '^version = ' $project/pyproject.toml | sed 's/version = "\(.*\)"/\1/')
            if [[ -z "$VERSION" ]]; then
              echo "‚ùå Could not extract version from $project/pyproject.toml"
              continue
            fi

            # Get fresh sequence number for this tag
            SEQ_NUM=$(get_next_sequence "$RELEASE_DATE")
            echo "üìã Using sequence number: $SEQ_NUM for $project on $RELEASE_DATE"

            # New tag format: yyyy.mm.dd.NN/project-vX.Y.Z
            TAG_NAME="${RELEASE_DATE}.${SEQ_NUM}/${project}-v${VERSION}"
            echo "üìã Creating tag: $TAG_NAME"

            if git tag -l | grep -q "^$TAG_NAME$"; then
              echo "‚ö†Ô∏è Tag $TAG_NAME already exists, skipping"
              continue
            fi

            git tag -a "$TAG_NAME" -m "Release $project v$VERSION - Automated release (${RELEASE_DATE}.${SEQ_NUM})"
            git push origin "$TAG_NAME"
            echo "‚úÖ Successfully created and pushed tag: $TAG_NAME"

            echo "Creating GitHub Release for $TAG_NAME..."
            gh release create "$TAG_NAME" \
              --title "üöÄ $project v$VERSION (${RELEASE_DATE}.${SEQ_NUM})" \
              --notes "Release $project v$VERSION - Automated release generated with Claude Code" \
              --latest=$(if [[ "$project" == "myscheduler" ]]; then echo "true"; else echo "false"; fi)

            echo "‚úÖ Successfully created GitHub Release: $TAG_NAME"
          done
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}

      - name: Create multi-project release (if applicable)
        if: needs.detect-changes.outputs.is_multi_project == 'true'
        run: |
          # Get current date in YYYY.MM.DD format
          RELEASE_DATE=$(date +%Y.%m.%d)

          # Function to get next sequential number for the current date
          get_next_sequence() {
            local date_pattern="$1"
            # Fetch all tags from remote
            git fetch --tags
            # Find all tags matching the date pattern and extract sequence numbers
            local max_seq=$(git tag -l "${date_pattern}.*/*" | \
              sed -n "s|^${date_pattern}\.\([0-9]\{2\}\)/.*|\1|p" | \
              sort -n | tail -1)

            if [[ -z "$max_seq" ]]; then
              echo "01"
            else
              printf "%02d" $((10#$max_seq + 1))
            fi
          }

          # Get the next sequence number for today
          SEQ_NUM=$(get_next_sequence "$RELEASE_DATE")
          echo "üìã Using sequence number: $SEQ_NUM for multi-project release on $RELEASE_DATE"

          # New tag format: yyyy.mm.dd.NN/multi-vYYYY.MM.DD
          TAG_NAME="${RELEASE_DATE}.${SEQ_NUM}/multi-v${RELEASE_DATE}"

          if git tag -l | grep -q "^$TAG_NAME$"; then
            echo "‚ö†Ô∏è Multi-project tag $TAG_NAME already exists, skipping"
          else
            echo "üìã Creating multi-project release tag: $TAG_NAME"

            # Build release notes from all changed projects
            RELEASE_NOTES="# Multi-Project Release ${RELEASE_DATE}.${SEQ_NUM}"$'\n\n'
            RELEASE_NOTES+="This release includes updates to multiple projects:"$'\n\n'

            IFS=',' read -ra PROJECTS <<< "${{ needs.detect-changes.outputs.changed_projects }}"
            for project in "${PROJECTS[@]}"; do
              if [[ -f "$project/pyproject.toml" ]]; then
                VERSION=$(grep '^version = ' $project/pyproject.toml | sed 's/version = "\(.*\)"/\1/')
                RELEASE_NOTES+="- **$project**: v$VERSION"$'\n'
              fi
            done

            RELEASE_NOTES+=$'\n'"---"$'\n'
            RELEASE_NOTES+="ü§ñ Generated with [Claude Code](https://claude.com/claude-code)"

            git config --global user.name "github-actions[bot]"
            git config --global user.email "github-actions[bot]@users.noreply.github.com"

            git tag -a "$TAG_NAME" -m "Multi-project release ${RELEASE_DATE}.${SEQ_NUM}"
            git push origin "$TAG_NAME"
            echo "‚úÖ Successfully created and pushed multi-project tag: $TAG_NAME"

            echo "$RELEASE_NOTES" > multi-release-notes.md

            gh release create "$TAG_NAME" \
              --title "üöÄ Multi-Project Release ${RELEASE_DATE}.${SEQ_NUM}" \
              --notes-file multi-release-notes.md \
              --latest=false

            echo "‚úÖ Successfully created multi-project GitHub Release: $TAG_NAME"
          fi
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}

      - name: Summary
        run: |
          echo "üéâ Automatic Release and Tagging completed successfully!"
          echo ""
          echo "üìã Processed projects: ${{ needs.detect-changes.outputs.changed_projects }}"
          echo "üîÑ Multi-project release: ${{ needs.detect-changes.outputs.is_multi_project }}"