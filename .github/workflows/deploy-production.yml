name: Deploy to Production

on:
  # æœ¬ç•ªãƒ‡ãƒ—ãƒ­ã‚¤ã¯æ‰‹å‹•å®Ÿè¡Œã®ã¿ã«åˆ¶é™
  # push:
  #   branches: [main]
  #   paths:
  #     - 'myscheduler/**'
  #     - '.github/workflows/**'
  workflow_dispatch:
    inputs:
      version:
        description: 'Version to deploy (e.g., v1.2.3)'
        required: true
        type: string
      skip_tests:
        description: 'Skip pre-deployment tests (emergency only)'
        required: false
        type: boolean
        default: false

defaults:
  run:
    working-directory: ./myscheduler

env:
  REGISTRY: ghcr.io
  IMAGE_NAME: ${{ github.repository }}/myscheduler

jobs:
  validate-production:
    name: Validate Production Deployment
    runs-on: ubuntu-latest

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Validate deployment prerequisites
        run: |
          echo "ğŸ” Validating production deployment prerequisites"

          if [[ "${{ github.event_name }}" == "push" ]]; then
            echo "âœ… Automatic deployment from release/* merge to main"
          else
            echo "âœ… Manual deployment triggered with version: ${{ inputs.version }}"
            if [[ "${{ inputs.skip_tests }}" == "true" ]]; then
              echo "âš ï¸ WARNING: Pre-deployment tests will be skipped (emergency deployment)"
            fi
          fi

      - name: Check for production readiness
        run: |
          echo "ğŸ“‹ Production readiness checklist:"
          echo "  âœ… All required tests passed in previous stages"
          echo "  âœ… Security scans completed"
          echo "  âœ… Code reviewed and approved"
          echo "  âœ… Release notes prepared"

  pre-deployment-tests:
    name: Pre-deployment Tests
    runs-on: ubuntu-latest
    needs: [validate-production]
    if: github.event_name == 'push' || inputs.skip_tests != true

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Python
        uses: actions/setup-python@v4
        with:
          python-version: '3.12'

      - name: Install uv
        uses: astral-sh/setup-uv@v3
        with:
          version: "latest"

      - name: Install dependencies
        run: uv sync --extra dev

      - name: Run critical production tests
        run: |
          echo "ğŸ§ª Running critical production tests"
          uv run pytest tests/ -v -m "production" --cov=app --cov-report=xml --cov-report=term || \
          if [ $? -eq 5 ]; then
            echo "âš ï¸ No production-marked tests found, running critical tests instead"
            uv run pytest tests/ -v -m "critical" --cov=app --cov-report=xml --cov-report=term
          else
            exit $?
          fi

      - name: Final security scan
        uses: aquasecurity/trivy-action@master
        with:
          scan-type: 'fs'
          scan-ref: './myscheduler'
          format: 'table'
          exit-code: '1'
          severity: 'CRITICAL,HIGH'

  backup-production:
    name: Backup Production
    runs-on: ubuntu-latest
    needs: [pre-deployment-tests]
    if: always() && (needs.pre-deployment-tests.result == 'success' || needs.pre-deployment-tests.result == 'skipped')
    environment: production

    defaults:
      run:
        working-directory: .

    steps:
      - name: Create production backup
        run: |
          echo "ğŸ’¾ Creating production backup"
          echo "â„¹ï¸ In actual deployment, this would:"
          echo "  - Create database backup using kubectl/pg_dump"
          echo "  - Backup configuration files"
          echo "  - Store backup metadata"
          # ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹ãƒãƒƒã‚¯ã‚¢ãƒƒãƒ—
          # kubectl exec deployment/myscheduler-prod -- pg_dump -U user -h localhost myscheduler > backup-$(date +%Y%m%d-%H%M%S).sql

          # è¨­å®šãƒ•ã‚¡ã‚¤ãƒ«ãƒãƒƒã‚¯ã‚¢ãƒƒãƒ—
          # kubectl get configmap myscheduler-config -o yaml > config-backup-$(date +%Y%m%d-%H%M%S).yaml

      - name: Store backup location
        run: |
          echo "backup_timestamp=$(date +%Y%m%d-%H%M%S)" >> $GITHUB_OUTPUT

  deploy-production:
    name: Deploy to Production
    runs-on: ubuntu-latest
    needs: [backup-production]
    environment: production

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Determine version and image tag
        id: version
        run: |
          if [[ "${{ github.event_name }}" == "workflow_dispatch" ]]; then
            VERSION="${{ inputs.version }}"
          else
            VERSION="v$(grep '^version = ' pyproject.toml | sed 's/version = "\(.*\)"/\1/')"
          fi
          echo "version=$VERSION" >> $GITHUB_OUTPUT

      - name: Log in to Container Registry
        uses: docker/login-action@v3
        with:
          registry: ${{ env.REGISTRY }}
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Pull and verify production image
        run: |
          docker pull ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:${{ steps.version.outputs.version }}
          docker tag ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:${{ steps.version.outputs.version }} \
                     ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:latest

      - name: Push latest tag
        run: |
          docker push ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:latest

      - name: Blue-Green deployment
        run: |
          echo "ğŸ”„ Starting blue-green deployment to production"
          echo "Version: ${{ steps.version.outputs.version }}"

          # Blue-Green ãƒ‡ãƒ—ãƒ­ã‚¤ãƒ¡ãƒ³ãƒˆä¾‹
          # 1. æ–°ã—ã„ãƒãƒ¼ã‚¸ãƒ§ãƒ³ã‚’ã‚°ãƒªãƒ¼ãƒ³ç’°å¢ƒã«ãƒ‡ãƒ—ãƒ­ã‚¤
          # kubectl set image deployment/myscheduler-green myscheduler=${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:${{ steps.version.outputs.version }}
          # kubectl rollout status deployment/myscheduler-green --timeout=300s

          # 2. ãƒ˜ãƒ«ã‚¹ãƒã‚§ãƒƒã‚¯
          # kubectl exec deployment/myscheduler-green -- curl -f http://localhost:8000/health

          # 3. ãƒˆãƒ©ãƒ•ã‚£ãƒƒã‚¯ã‚’æ®µéšçš„ã«åˆ‡ã‚Šæ›¿ãˆ
          # kubectl patch service myscheduler-service -p '{"spec":{"selector":{"version":"green"}}}'

      - name: Wait for deployment stabilization
        run: |
          echo "â³ Waiting for deployment to stabilize..."
          sleep 60

  post-deployment-verification:
    name: Post-deployment Verification
    runs-on: ubuntu-latest
    needs: [deploy-production]

    steps:
      - name: Production health check
        run: |
          echo "â¤ï¸ Running production health check"
          # curl -f https://api.myscheduler.example.com/health || exit 1

      - name: Critical functionality tests
        run: |
          echo "ğŸ” Testing critical functionality"
          # æœ¬ç•ªç’°å¢ƒã®é‡è¦æ©Ÿèƒ½ãƒ†ã‚¹ãƒˆ
          # newman run postman-collection.json --env-var baseUrl=https://api.myscheduler.example.com

      - name: Performance monitoring
        run: |
          echo "ğŸ“Š Checking performance metrics"
          # ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹ãƒ¡ãƒˆãƒªã‚¯ã‚¹ã®ç¢ºèª
          # curl -s https://monitoring.example.com/api/metrics/myscheduler

      - name: Smoke tests
        run: |
          echo "ğŸ’¨ Running production smoke tests"
          # æœ¬ç•ªç’°å¢ƒã‚¹ãƒ¢ãƒ¼ã‚¯ãƒ†ã‚¹ãƒˆ

  create-release:
    name: Create GitHub Release
    runs-on: ubuntu-latest
    needs: [post-deployment-verification]

    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Get version
        id: version
        run: |
          if [[ "${{ github.event_name }}" == "workflow_dispatch" ]]; then
            VERSION="${{ inputs.version }}"
          else
            VERSION="v$(grep '^version = ' myscheduler/pyproject.toml | sed 's/version = "\(.*\)"/\1/')"
          fi
          echo "version=$VERSION" >> $GITHUB_OUTPUT

      - name: Generate release notes
        id: release-notes
        run: |
          CURRENT_VERSION="${{ steps.version.outputs.version }}"
          PREVIOUS_TAG=$(git describe --tags --abbrev=0 --exclude="$CURRENT_VERSION" 2>/dev/null || echo "")

          {
            echo "## ğŸš€ What's New"
            echo ""
            if [[ -n "$PREVIOUS_TAG" ]]; then
              git log --pretty=format:"- %s (%an)" $PREVIOUS_TAG..HEAD --grep="^feat" | head -10
            fi
            echo ""
            echo "## ğŸ› Bug Fixes"
            echo ""
            if [[ -n "$PREVIOUS_TAG" ]]; then
              git log --pretty=format:"- %s (%an)" $PREVIOUS_TAG..HEAD --grep="^fix" | head -10
            fi
            echo ""
            echo "## ğŸ“ Full Changelog"
            echo ""
            if [[ -n "$PREVIOUS_TAG" ]]; then
              echo "**Full Changelog**: [$PREVIOUS_TAG...$CURRENT_VERSION](https://github.com/${{ github.repository }}/compare/$PREVIOUS_TAG...$CURRENT_VERSION)"
            fi
          } > release-notes.md

      - name: Create Release
        uses: softprops/action-gh-release@v1
        with:
          tag_name: ${{ steps.version.outputs.version }}
          name: Release ${{ steps.version.outputs.version }}
          body_path: release-notes.md
          draft: false
          prerelease: false

  rollback:
    name: Rollback on Failure
    runs-on: ubuntu-latest
    needs: [post-deployment-verification]
    if: failure()
    environment: production

    defaults:
      run:
        working-directory: .

    steps:
      - name: Emergency rollback
        run: |
          echo "ğŸš¨ Emergency rollback initiated"
          echo "â„¹ï¸ In actual deployment, this would:"
          echo "  - Rollback to previous version using kubectl"
          echo "  - Verify rollback status"
          # å‰ã®ãƒãƒ¼ã‚¸ãƒ§ãƒ³ã«å³åº§ã«ãƒ­ãƒ¼ãƒ«ãƒãƒƒã‚¯
          # kubectl rollout undo deployment/myscheduler-prod
          # kubectl rollout status deployment/myscheduler-prod

      - name: Restore from backup
        if: env.RESTORE_DATA == 'true'
        run: |
          echo "ğŸ’¾ Restoring data from backup"
          # ãƒãƒƒã‚¯ã‚¢ãƒƒãƒ—ã‹ã‚‰ãƒ‡ãƒ¼ã‚¿å¾©æ—§

      - name: Notify emergency
        run: |
          echo "ğŸš¨ Production deployment failed - Emergency rollback completed"
          # ç·Šæ€¥é€šçŸ¥
          # curl -X POST -H 'Content-type: application/json' \
          #   --data '{"text":"ğŸš¨ EMERGENCY: MyScheduler production deployment failed and was rolled back"}' \
          #   ${{ secrets.SLACK_EMERGENCY_WEBHOOK_URL }}

  success-notification:
    name: Success Notification
    runs-on: ubuntu-latest
    needs: [create-release]

    steps:
      - name: Notify successful deployment
        run: |
          echo "âœ… Production deployment successful"
          # æˆåŠŸé€šçŸ¥
          # curl -X POST -H 'Content-type: application/json' \
          #   --data '{"text":"âœ… MyScheduler ${{ needs.create-release.outputs.version }} deployed to production successfully!"}' \
          #   ${{ secrets.SLACK_WEBHOOK_URL }}

      - name: Update monitoring dashboards
        run: |
          echo "ğŸ“Š Updating monitoring dashboards with new version"
          # ãƒ¢ãƒ‹ã‚¿ãƒªãƒ³ã‚°ãƒ€ãƒƒã‚·ãƒ¥ãƒœãƒ¼ãƒ‰ã®æ›´æ–°