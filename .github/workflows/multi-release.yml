name: "üöÄ Release Quality Assurance"

on:
  # Multi-project release workflow with automated version management and manual trigger support
  push:
    branches:
      - 'release/**'
    paths-ignore:
      - 'docs/**'
      - '**.md'
  pull_request:
    branches: [staging, main]
    types: [opened, synchronize, reopened]
    paths-ignore:
      - 'docs/**'
      - '**.md'
  workflow_dispatch:
    inputs:
      release_type:
        description: 'Release type for version bump'
        required: true
        type: choice
        options: ['major', 'minor', 'patch', 'custom']
        default: 'minor'
      custom_version:
        description: 'Custom version (only if release_type is custom)'
        required: false
        type: string
      projects:
        description: 'Projects to release (comma-separated, e.g., "myscheduler,jobqueue" or single project)'
        required: true
        type: string
        default: 'myscheduler'

env:
  REGISTRY: ghcr.io

jobs:
  create-release-branch:
    name: Create Release Branch
    runs-on: ubuntu-latest
    if: github.event_name == 'workflow_dispatch'
    outputs:
      release_branch: ${{ steps.branch.outputs.branch_name }}
      projects_json: ${{ steps.parse.outputs.projects_json }}

    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          token: ${{ secrets.GITHUB_TOKEN }}

      - name: Set up Python
        uses: actions/setup-python@v4
        with:
          python-version: '3.12'

      - name: Parse projects input
        id: parse
        run: |
          PROJECTS="${{ github.event.inputs.projects }}"
          echo "üìã Projects to release: $PROJECTS"

          # Convert comma-separated string to JSON array
          IFS=',' read -ra PROJECT_ARRAY <<< "$PROJECTS"
          PROJECTS_JSON="["
          for i in "${!PROJECT_ARRAY[@]}"; do
            PROJECT=$(echo "${PROJECT_ARRAY[$i]}" | xargs)  # Trim whitespace
            if [[ $i -gt 0 ]]; then
              PROJECTS_JSON+=","
            fi
            PROJECTS_JSON+="\"$PROJECT\""
          done
          PROJECTS_JSON+="]"

          echo "projects_json=$PROJECTS_JSON" >> $GITHUB_OUTPUT
          echo "‚úÖ Parsed projects: $PROJECTS_JSON"

      - name: Check for existing release
        id: check-existing
        run: |
          PROJECTS_JSON='${{ steps.parse.outputs.projects_json }}'
          RELEASE_TYPE="${{ github.event.inputs.release_type }}"
          CUSTOM_VERSION="${{ github.event.inputs.custom_version }}"

          # Parse projects from JSON
          PROJECTS=($(echo "$PROJECTS_JSON" | jq -r '.[]'))

          # Determine branch naming strategy
          if [[ ${#PROJECTS[@]} -eq 1 ]]; then
            # Single project: release/{project}/vX.Y.Z
            PROJECT="${PROJECTS[0]}"

            # Calculate potential version
            if [[ "$RELEASE_TYPE" == "custom" && -n "$CUSTOM_VERSION" ]]; then
              POTENTIAL_VERSION="$CUSTOM_VERSION"
            else
              if [[ "$PROJECT" == "docs" && ! -f "$PROJECT/pyproject.toml" ]]; then
                CURRENT_VERSION="0.1.0"
              else
                CURRENT_VERSION=$(grep '^version = ' $PROJECT/pyproject.toml | sed 's/version = "\(.*\)"/\1/' || echo "0.1.0")
              fi

              IFS='.' read -r major minor patch <<< "$CURRENT_VERSION"
              case "$RELEASE_TYPE" in
                "major") major=$((major + 1)); minor=0; patch=0 ;;
                "minor") minor=$((minor + 1)); patch=0 ;;
                "patch") patch=$((patch + 1)) ;;
              esac
              POTENTIAL_VERSION="$major.$minor.$patch"
            fi

            BRANCH_NAME="release/${PROJECT}/v${POTENTIAL_VERSION}"
          else
            # Multi-project: release/multi/vYYYY.MM.DD or custom version
            if [[ "$RELEASE_TYPE" == "custom" && -n "$CUSTOM_VERSION" ]]; then
              POTENTIAL_VERSION="$CUSTOM_VERSION"
            else
              POTENTIAL_VERSION="$(date +%Y.%m.%d)"
            fi
            BRANCH_NAME="release/multi/v${POTENTIAL_VERSION}"
          fi

          # Check if branch already exists
          if git ls-remote --exit-code --heads origin "$BRANCH_NAME" >/dev/null 2>&1; then
            echo "branch_exists=true" >> $GITHUB_OUTPUT
            echo "potential_branch=$BRANCH_NAME" >> $GITHUB_OUTPUT
            echo "‚ö†Ô∏è Warning: Release branch $BRANCH_NAME already exists"
            echo "This workflow will delete and recreate it with updated changes."
          else
            echo "branch_exists=false" >> $GITHUB_OUTPUT
            echo "potential_branch=$BRANCH_NAME" >> $GITHUB_OUTPUT
            echo "‚úÖ Branch $BRANCH_NAME is available for creation"
          fi

      - name: Calculate versions for all projects
        id: version
        run: |
          PROJECTS_JSON='${{ steps.parse.outputs.projects_json }}'
          RELEASE_TYPE="${{ github.event.inputs.release_type }}"
          CUSTOM_VERSION="${{ github.event.inputs.custom_version }}"

          # Parse projects from JSON
          PROJECTS=($(echo "$PROJECTS_JSON" | jq -r '.[]'))

          echo "üìã Calculating versions for ${#PROJECTS[@]} project(s)"

          # Build version map
          VERSION_MAP="{"
          for i in "${!PROJECTS[@]}"; do
            PROJECT="${PROJECTS[$i]}"

            if [[ "$RELEASE_TYPE" == "custom" && -n "$CUSTOM_VERSION" ]]; then
              NEW_VERSION="$CUSTOM_VERSION"
            else
              # Detect project language and extract version
              if [[ "$PROJECT" == "docs" && ! -f "$PROJECT/pyproject.toml" ]]; then
                CURRENT_VERSION="0.1.0"
              elif [[ -f "$PROJECT/pyproject.toml" ]]; then
                # Python project
                CURRENT_VERSION=$(grep '^version = ' $PROJECT/pyproject.toml | sed 's/version = "\(.*\)"/\1/' || echo "0.1.0")
              elif [[ -f "$PROJECT/package.json" ]]; then
                # TypeScript/Node.js project
                CURRENT_VERSION=$(jq -r '.version // "0.1.0"' $PROJECT/package.json)
              else
                CURRENT_VERSION="0.1.0"
              fi

              IFS='.' read -r major minor patch <<< "$CURRENT_VERSION"
              case "$RELEASE_TYPE" in
                "major") major=$((major + 1)); minor=0; patch=0 ;;
                "minor") minor=$((minor + 1)); patch=0 ;;
                "patch") patch=$((patch + 1)) ;;
              esac
              NEW_VERSION="$major.$minor.$patch"
            fi

            if [[ $i -gt 0 ]]; then
              VERSION_MAP+=","
            fi
            VERSION_MAP+="\"$PROJECT\":\"$NEW_VERSION\""

            echo "‚úÖ $PROJECT: $NEW_VERSION"
          done
          VERSION_MAP+="}"

          echo "version_map=$VERSION_MAP" >> $GITHUB_OUTPUT
          echo "üöÄ Version map: $VERSION_MAP"

      - name: Update version files for all projects
        run: |
          PROJECTS_JSON='${{ steps.parse.outputs.projects_json }}'
          VERSION_MAP='${{ steps.version.outputs.version_map }}'

          # Parse projects from JSON
          PROJECTS=($(echo "$PROJECTS_JSON" | jq -r '.[]'))

          echo "üìù Updating version files for ${#PROJECTS[@]} project(s)"

          for PROJECT in "${PROJECTS[@]}"; do
            NEW_VERSION=$(echo "$VERSION_MAP" | jq -r ".[\"$PROJECT\"]")

            # Detect project language and update version file
            if [[ "$PROJECT" == "docs" ]]; then
              # Docs project special handling
              if [[ ! -f "$PROJECT/pyproject.toml" ]]; then
                echo "üìù Creating pyproject.toml for docs project"
                echo '[project]' > $PROJECT/pyproject.toml
                echo 'name = "docs"' >> $PROJECT/pyproject.toml
                echo "version = \"$NEW_VERSION\"" >> $PROJECT/pyproject.toml
                echo 'description = "Documentation for MySwiftAgent"' >> $PROJECT/pyproject.toml
                echo 'authors = [' >> $PROJECT/pyproject.toml
                echo '    {name = "MySwiftAgent Team", email = "noreply@example.com"},' >> $PROJECT/pyproject.toml
                echo ']' >> $PROJECT/pyproject.toml
                echo '' >> $PROJECT/pyproject.toml
                echo '[build-system]' >> $PROJECT/pyproject.toml
                echo 'requires = ["hatchling"]' >> $PROJECT/pyproject.toml
                echo 'build-backend = "hatchling.build"' >> $PROJECT/pyproject.toml
              else
                sed -i "s/^version = \".*\"/version = \"$NEW_VERSION\"/" $PROJECT/pyproject.toml
              fi
              echo "‚úÖ Updated $PROJECT/pyproject.toml to version $NEW_VERSION"
              cat $PROJECT/pyproject.toml | grep "^version = "

            elif [[ -f "$PROJECT/pyproject.toml" ]]; then
              # Python project
              sed -i "s/^version = \".*\"/version = \"$NEW_VERSION\"/" $PROJECT/pyproject.toml
              echo "‚úÖ Updated $PROJECT/pyproject.toml to version $NEW_VERSION"
              cat $PROJECT/pyproject.toml | grep "^version = "

            elif [[ -f "$PROJECT/package.json" ]]; then
              # TypeScript/Node.js project
              jq ".version = \"$NEW_VERSION\"" $PROJECT/package.json > $PROJECT/package.json.tmp
              mv $PROJECT/package.json.tmp $PROJECT/package.json
              echo "‚úÖ Updated $PROJECT/package.json to version $NEW_VERSION"
              cat $PROJECT/package.json | jq -r '.version'

            else
              echo "‚ö†Ô∏è No version file found for $PROJECT (expected pyproject.toml or package.json)"
            fi
          done

      - name: Create release branch
        id: branch
        run: |
          PROJECTS_JSON='${{ steps.parse.outputs.projects_json }}'
          VERSION_MAP='${{ steps.version.outputs.version_map }}'
          RELEASE_TYPE="${{ github.event.inputs.release_type }}"

          # Parse projects from JSON
          PROJECTS=($(echo "$PROJECTS_JSON" | jq -r '.[]'))

          # Determine branch name
          if [[ ${#PROJECTS[@]} -eq 1 ]]; then
            PROJECT="${PROJECTS[0]}"
            NEW_VERSION=$(echo "$VERSION_MAP" | jq -r ".[\"$PROJECT\"]")
            BRANCH_NAME="release/${PROJECT}/v${NEW_VERSION}"
            COMMIT_MSG="üîñ Bump version to $NEW_VERSION for $PROJECT release"
          else
            if [[ "$RELEASE_TYPE" == "custom" && -n "${{ github.event.inputs.custom_version }}" ]]; then
              RELEASE_VERSION="${{ github.event.inputs.custom_version }}"
            else
              RELEASE_VERSION="$(date +%Y.%m.%d)"
            fi
            BRANCH_NAME="release/multi/v${RELEASE_VERSION}"
            COMMIT_MSG="üîñ Multi-project release v${RELEASE_VERSION}"
          fi

          # Êó¢Â≠ò„Éñ„É©„É≥„ÉÅ„ÅÆÁ¢∫Ë™ç„Å®ÂâäÈô§
          if git ls-remote --exit-code --heads origin "$BRANCH_NAME" >/dev/null 2>&1; then
            echo "‚ö†Ô∏è Branch $BRANCH_NAME already exists, deleting..."
            git push origin --delete "$BRANCH_NAME"
          fi

          # develop„Åã„ÇâÊñ∞„Åó„ÅÑ„É™„É™„Éº„Çπ„Éñ„É©„É≥„ÉÅ„Çí‰ΩúÊàê
          git config --global user.name "github-actions[bot]"
          git config --global user.email "github-actions[bot]@users.noreply.github.com"

          git checkout -b "$BRANCH_NAME"

          # Add all modified version files (pyproject.toml or package.json)
          for PROJECT in "${PROJECTS[@]}"; do
            if [[ -f "$PROJECT/pyproject.toml" ]]; then
              git add $PROJECT/pyproject.toml
            fi
            if [[ -f "$PROJECT/package.json" ]]; then
              git add $PROJECT/package.json
            fi
          done

          # Build commit message with version details
          COMMIT_DETAILS=""
          for PROJECT in "${PROJECTS[@]}"; do
            NEW_VERSION=$(echo "$VERSION_MAP" | jq -r ".[\"$PROJECT\"]")
            COMMIT_DETAILS+="- $PROJECT: v$NEW_VERSION"$'\n'
          done

          FULL_MESSAGE="$COMMIT_MSG"$'\n\n'"$COMMIT_DETAILS"$'\n'"Release type: $RELEASE_TYPE"$'\n\n'"ü§ñ Generated with [Claude Code](https://claude.ai/code)"$'\n\n'"Co-Authored-By: Claude <noreply@anthropic.com>"

          git commit -m "$FULL_MESSAGE"

          git push origin "$BRANCH_NAME"

          echo "branch_name=$BRANCH_NAME" >> $GITHUB_OUTPUT
          echo "üåø Created release branch: $BRANCH_NAME"

      - name: Create pull request
        run: |
          PROJECTS_JSON='${{ steps.parse.outputs.projects_json }}'
          VERSION_MAP='${{ steps.version.outputs.version_map }}'
          BRANCH_NAME="${{ steps.branch.outputs.branch_name }}"

          # Parse projects from JSON
          PROJECTS=($(echo "$PROJECTS_JSON" | jq -r '.[]'))

          # Build PR title and body
          if [[ ${#PROJECTS[@]} -eq 1 ]]; then
            PROJECT="${PROJECTS[0]}"
            NEW_VERSION=$(echo "$VERSION_MAP" | jq -r ".[\"$PROJECT\"]")
            PR_TITLE="üöÄ Release $PROJECT v$NEW_VERSION"
            PROJECT_LIST="- **Project**: $PROJECT"$'\n'"- **Version**: v$NEW_VERSION"
          else
            if [[ "${{ github.event.inputs.release_type }}" == "custom" && -n "${{ github.event.inputs.custom_version }}" ]]; then
              RELEASE_VERSION="${{ github.event.inputs.custom_version }}"
            else
              RELEASE_VERSION="$(date +%Y.%m.%d)"
            fi
            PR_TITLE="üöÄ Multi-Project Release v$RELEASE_VERSION"
            PROJECT_LIST="### Changed Projects"$'\n'
            for PROJECT in "${PROJECTS[@]}"; do
              NEW_VERSION=$(echo "$VERSION_MAP" | jq -r ".[\"$PROJECT\"]")
              PROJECT_LIST+="- **$PROJECT**: v$NEW_VERSION"$'\n'
            done
          fi

          RELEASE_TYPE_INPUT="${{ github.event.inputs.release_type }}"

          echo "## üì¶ Release Summary" > /tmp/pr-body.md
          echo "" >> /tmp/pr-body.md
          echo "$PROJECT_LIST" >> /tmp/pr-body.md
          echo "- **Release Type**: $RELEASE_TYPE_INPUT" >> /tmp/pr-body.md
          echo "" >> /tmp/pr-body.md
          echo "## üîÑ Automated Changes" >> /tmp/pr-body.md
          echo "" >> /tmp/pr-body.md
          echo "- ‚úÖ Version bump in pyproject.toml/package.json for all projects" >> /tmp/pr-body.md
          echo "- üåø Release branch created: \`$BRANCH_NAME\`" >> /tmp/pr-body.md
          echo "" >> /tmp/pr-body.md
          echo "## üìã Pre-merge Checklist" >> /tmp/pr-body.md
          echo "" >> /tmp/pr-body.md
          echo "- [ ] All CI checks pass" >> /tmp/pr-body.md
          echo "- [ ] QA tests completed" >> /tmp/pr-body.md
          echo "- [ ] Security scans clear" >> /tmp/pr-body.md
          echo "- [ ] Release notes reviewed" >> /tmp/pr-body.md
          echo "" >> /tmp/pr-body.md
          echo "## üéØ Next Steps" >> /tmp/pr-body.md
          echo "" >> /tmp/pr-body.md
          echo "1. Review and approve this PR" >> /tmp/pr-body.md
          echo "2. Merge to staging for UAT" >> /tmp/pr-body.md
          echo "3. Final merge to main for production release" >> /tmp/pr-body.md
          echo "" >> /tmp/pr-body.md
          echo "ü§ñ Generated with [Claude Code](https://claude.ai/code)" >> /tmp/pr-body.md

          gh pr create --title "$PR_TITLE" --body-file /tmp/pr-body.md --base staging --head "$BRANCH_NAME"
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
  validate-release:
    name: Validate Release
    runs-on: ubuntu-latest
    if: |
      github.event_name == 'push' &&
      startsWith(github.ref, 'refs/heads/release/')
    outputs:
      projects_json: ${{ steps.version.outputs.projects_json }}
      is_multi_project: ${{ steps.version.outputs.is_multi_project }}

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Extract projects and versions from branch
        id: version
        run: |
          BRANCH_NAME=${GITHUB_HEAD_REF:-${GITHUB_REF#refs/heads/}}
          echo "Branch name: $BRANCH_NAME"

          # Multi-project format: release/multi/vYYYY.MM.DD or vX.Y.Z
          if [[ $BRANCH_NAME =~ ^release/multi/v(.+)$ ]]; then
            echo "is_multi_project=true" >> $GITHUB_OUTPUT
            echo "valid=true" >> $GITHUB_OUTPUT
            echo "‚úÖ Multi-project release detected"

            # Detect changed projects from git diff
            CHANGED_PROJECTS=""
            for project in myscheduler jobqueue docs commonUI graphAiServer expertAgent; do
              # Check if project has version file (pyproject.toml or package.json)
              if ([[ -f "$project/pyproject.toml" ]] || [[ -f "$project/package.json" ]]) && git diff HEAD~1 HEAD --name-only | grep -q "^$project/"; then
                if [[ -z "$CHANGED_PROJECTS" ]]; then
                  CHANGED_PROJECTS="$project"
                else
                  CHANGED_PROJECTS="$CHANGED_PROJECTS,$project"
                fi
              fi
            done

            # Convert to JSON array
            IFS=',' read -ra PROJECT_ARRAY <<< "$CHANGED_PROJECTS"
            PROJECTS_JSON="["
            for i in "${!PROJECT_ARRAY[@]}"; do
              if [[ $i -gt 0 ]]; then
                PROJECTS_JSON+=","
              fi
              PROJECTS_JSON+="\"${PROJECT_ARRAY[$i]}\""
            done
            PROJECTS_JSON+="]"

            echo "projects_json=$PROJECTS_JSON" >> $GITHUB_OUTPUT
            echo "‚úÖ Changed projects: $CHANGED_PROJECTS"

          # Single project format: release/{project}/vX.Y.Z
          elif [[ $BRANCH_NAME =~ ^release/([^/]+)/v([0-9]+\.[0-9]+\.[0-9]+)$ ]]; then
            PROJECT=${BASH_REMATCH[1]}
            VERSION=${BASH_REMATCH[2]}
            echo "is_multi_project=false" >> $GITHUB_OUTPUT
            echo "projects_json=[\"$PROJECT\"]" >> $GITHUB_OUTPUT
            echo "valid=true" >> $GITHUB_OUTPUT
            echo "‚úÖ Single project release detected: $PROJECT v$VERSION"

          # Legacy format: release/vX.Y.Z (assumes myscheduler)
          elif [[ $BRANCH_NAME =~ ^release/v?([0-9]+\.[0-9]+\.[0-9]+)$ ]]; then
            VERSION=${BASH_REMATCH[1]}
            echo "is_multi_project=false" >> $GITHUB_OUTPUT
            echo "projects_json=[\"myscheduler\"]" >> $GITHUB_OUTPUT
            echo "valid=true" >> $GITHUB_OUTPUT
            echo "‚ö†Ô∏è Legacy format detected: assuming myscheduler v$VERSION"

          else
            echo "valid=false" >> $GITHUB_OUTPUT
          fi

      - name: Validate version format
        if: steps.version.outputs.valid != 'true'
        run: |
          echo "‚ùå Invalid release branch format."
          echo "Expected formats:"
          echo "  - release/{project}/vX.Y.Z (single project)"
          echo "  - release/multi/vYYYY.MM.DD (multi-project)"
          echo "  - release/vX.Y.Z (legacy, assumes myscheduler)"
          exit 1

      - name: Validate project directories and versions
        run: |
          PROJECTS_JSON='${{ steps.version.outputs.projects_json }}'
          PROJECTS=($(echo "$PROJECTS_JSON" | jq -r '.[]'))

          echo "üìã Validating ${#PROJECTS[@]} project(s)"

          for PROJECT in "${PROJECTS[@]}"; do
            echo "Validating $PROJECT..."

            # Check if project directory exists
            if [[ ! -d "$PROJECT" ]]; then
              echo "‚ùå Project directory '$PROJECT' does not exist"
              exit 1
            fi

            # For docs project, pyproject.toml might not exist yet
            if [[ "$PROJECT" == "docs" ]]; then
              if [[ ! -f "$PROJECT/pyproject.toml" ]]; then
                echo "‚ÑπÔ∏è pyproject.toml will be created for docs project"
              fi
            else
              # Check if version file exists (pyproject.toml or package.json)
              if [[ ! -f "$PROJECT/pyproject.toml" ]] && [[ ! -f "$PROJECT/package.json" ]]; then
                echo "‚ùå No version file found in '$PROJECT/' (expected pyproject.toml or package.json)"
                exit 1
              fi
            fi

            echo "‚úÖ Project '$PROJECT' validated"
          done

  test:
    name: Test Suite (${{ matrix.project }})
    runs-on: ubuntu-latest
    needs: [validate-release]
    strategy:
      matrix:
        project: ${{ fromJson(needs.validate-release.outputs.projects_json) }}
      fail-fast: false

    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        if: matrix.project != 'docs'

      - name: Detect project language
        id: detect-lang
        if: matrix.project != 'docs'
        run: |
          if [[ -f "${{ matrix.project }}/pyproject.toml" ]]; then
            echo "language=python" >> $GITHUB_OUTPUT
            echo "üêç Detected Python project"
          elif [[ -f "${{ matrix.project }}/package.json" ]]; then
            echo "language=typescript" >> $GITHUB_OUTPUT
            echo "üìò Detected TypeScript/Node.js project"
          else
            echo "language=unknown" >> $GITHUB_OUTPUT
            echo "‚ö†Ô∏è Unknown project type"
          fi

      # Python project setup
      - name: Set up Python
        uses: actions/setup-python@v4
        if: matrix.project != 'docs' && steps.detect-lang.outputs.language == 'python'
        with:
          python-version: '3.12'

      - name: Install uv
        uses: astral-sh/setup-uv@v3
        if: matrix.project != 'docs' && steps.detect-lang.outputs.language == 'python'
        with:
          version: "latest"

      - name: Install Python dependencies
        if: matrix.project != 'docs' && steps.detect-lang.outputs.language == 'python'
        working-directory: ./${{ matrix.project }}
        run: uv sync --extra dev

      - name: Run Python linting
        if: matrix.project != 'docs' && steps.detect-lang.outputs.language == 'python'
        working-directory: ./${{ matrix.project }}
        run: uv run ruff check .

      - name: Run Python type checking
        if: matrix.project != 'docs' && steps.detect-lang.outputs.language == 'python'
        working-directory: ./${{ matrix.project }}
        run: uv run mypy app/

      - name: Run Python unit tests
        if: matrix.project != 'docs' && steps.detect-lang.outputs.language == 'python'
        working-directory: ./${{ matrix.project }}
        run: uv run pytest tests/unit/ -v

      - name: Run Python integration tests
        if: matrix.project != 'docs' && steps.detect-lang.outputs.language == 'python'
        working-directory: ./${{ matrix.project }}
        run: uv run pytest tests/integration/ -v

      # TypeScript/Node.js project setup
      - name: Setup Node.js
        uses: actions/setup-node@v4
        if: matrix.project != 'docs' && steps.detect-lang.outputs.language == 'typescript'
        with:
          node-version: '20'
          cache: 'npm'
          cache-dependency-path: ${{ matrix.project }}/package-lock.json

      - name: Install Node.js dependencies
        if: matrix.project != 'docs' && steps.detect-lang.outputs.language == 'typescript'
        working-directory: ./${{ matrix.project }}
        run: npm ci

      - name: Run TypeScript linting
        if: matrix.project != 'docs' && steps.detect-lang.outputs.language == 'typescript'
        working-directory: ./${{ matrix.project }}
        run: npm run lint

      - name: Run TypeScript type checking
        if: matrix.project != 'docs' && steps.detect-lang.outputs.language == 'typescript'
        working-directory: ./${{ matrix.project }}
        run: npm run type-check || npx tsc --noEmit

      - name: Run TypeScript tests
        if: matrix.project != 'docs' && steps.detect-lang.outputs.language == 'typescript'
        working-directory: ./${{ matrix.project }}
        run: npm test

      - name: Run TypeScript build
        if: matrix.project != 'docs' && steps.detect-lang.outputs.language == 'typescript'
        working-directory: ./${{ matrix.project }}
        run: npm run build

  docs-validation:
    name: Documentation Validation (${{ matrix.project }})
    runs-on: ubuntu-latest
    needs: [validate-release]
    strategy:
      matrix:
        project: ${{ fromJson(needs.validate-release.outputs.projects_json) }}

    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        if: matrix.project == 'docs'

      - name: Setup Node.js for markdown linting
        uses: actions/setup-node@v4
        if: matrix.project == 'docs'
        with:
          node-version: '18'

      - name: Install markdown linter
        if: matrix.project == 'docs'
        run: npm install -g markdownlint-cli

      - name: Validate documentation structure
        if: matrix.project == 'docs'
        working-directory: ./docs
        run: |
          echo "üìÇ Validating documentation structure"
          ls -la
          echo "‚úÖ Documentation structure validated"

      - name: Lint markdown files
        if: matrix.project == 'docs'
        working-directory: ./docs
        run: |
          echo "üìù Linting markdown files"
          if find . -name "*.md" -type f | head -1 | grep -q .; then
            markdownlint **/*.md || echo "‚ö†Ô∏è Markdown linting issues found, but proceeding with release"
          else
            echo "‚ÑπÔ∏è No markdown files found"
          fi

  security-scan:
    name: Security Scan (${{ matrix.project }})
    runs-on: ubuntu-latest
    needs: [validate-release]
    strategy:
      matrix:
        project: ${{ fromJson(needs.validate-release.outputs.projects_json) }}
      fail-fast: false

    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        if: matrix.project != 'docs'

      - name: Run Trivy vulnerability scanner
        uses: aquasecurity/trivy-action@master
        if: matrix.project != 'docs'
        with:
          scan-type: 'fs'
          scan-ref: './${{ matrix.project }}'
          format: 'table'
          exit-code: '1'
          severity: 'CRITICAL,HIGH'

  build-release:
    name: Build Release Candidate (${{ matrix.project }})
    runs-on: ubuntu-latest
    needs: [test, security-scan, validate-release]
    strategy:
      matrix:
        project: ${{ fromJson(needs.validate-release.outputs.projects_json) }}
      fail-fast: false

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Extract version
        id: version
        run: |
          BRANCH_NAME=${GITHUB_HEAD_REF:-${GITHUB_REF#refs/heads/}}
          VERSION=${BRANCH_NAME#release/}
          echo "version=$VERSION" >> $GITHUB_OUTPUT

      - name: Detect project language
        id: detect-lang
        run: |
          if [[ -f "${{ matrix.project }}/pyproject.toml" ]]; then
            echo "language=python" >> $GITHUB_OUTPUT
            echo "üêç Detected Python project"
          elif [[ -f "${{ matrix.project }}/package.json" ]]; then
            echo "language=typescript" >> $GITHUB_OUTPUT
            echo "üìò Detected TypeScript/Node.js project"
          else
            echo "language=unknown" >> $GITHUB_OUTPUT
            echo "‚ö†Ô∏è Unknown project type"
          fi

      - name: Get project version
        id: project-info
        run: |
          PROJECT="${{ matrix.project }}"

          if [[ -f "$PROJECT/pyproject.toml" ]]; then
            VERSION=$(grep '^version = ' $PROJECT/pyproject.toml | sed 's/version = "\(.*\)"/\1/' || echo "0.0.0")
          elif [[ -f "$PROJECT/package.json" ]]; then
            VERSION=$(jq -r '.version // "0.0.0"' $PROJECT/package.json)
          else
            VERSION="0.0.0"
          fi

          echo "project=$PROJECT" >> $GITHUB_OUTPUT
          echo "version=$VERSION" >> $GITHUB_OUTPUT
          echo "üéØ Building $PROJECT version $VERSION"

      # Python build steps
      - name: Set up Python
        uses: actions/setup-python@v4
        if: steps.detect-lang.outputs.language == 'python'
        with:
          python-version: '3.12'

      - name: Install uv
        uses: astral-sh/setup-uv@v3
        if: steps.detect-lang.outputs.language == 'python'
        with:
          version: "latest"

      - name: Build Python package
        if: steps.detect-lang.outputs.language == 'python'
        working-directory: ./${{ matrix.project }}
        run: uv build

      # TypeScript build steps
      - name: Setup Node.js
        uses: actions/setup-node@v4
        if: steps.detect-lang.outputs.language == 'typescript'
        with:
          node-version: '20'
          cache: 'npm'
          cache-dependency-path: ${{ matrix.project }}/package-lock.json

      - name: Install Node.js dependencies
        if: steps.detect-lang.outputs.language == 'typescript'
        working-directory: ./${{ matrix.project }}
        run: npm ci

      - name: Build TypeScript package
        if: steps.detect-lang.outputs.language == 'typescript'
        working-directory: ./${{ matrix.project }}
        run: npm run build

      # Docker build (common for both)
      - name: Build Docker image (verification only)
        run: |
          PROJECT="${{ matrix.project }}"
          VERSION="${{ steps.project-info.outputs.version }}"
          docker build -t $PROJECT:v$VERSION-test .
        working-directory: ./${{ matrix.project }}

      - name: Test release candidate
        run: |
          PROJECT="${{ matrix.project }}"
          VERSION="${{ steps.project-info.outputs.version }}"

          docker run --rm -d --name $PROJECT-rc-test -p 8000:8000 $PROJECT:v$VERSION-test
          sleep 10

          # „Éò„É´„Çπ„ÉÅ„Çß„ÉÉ„ÇØ
          echo "üîç Testing health endpoint..."
          curl -f http://localhost:8000/health || exit 1

          # APIÂü∫Êú¨Ê©üËÉΩ„ÉÜ„Çπ„Éà
          echo "üîç Testing API endpoints..."
          curl -f http://localhost:8000/api/v1/ || curl -f http://localhost:8000/ || exit 1

          docker stop $PROJECT-rc-test

      - name: Upload build artifacts
        uses: actions/upload-artifact@v4
        with:
          name: release-artifacts-${{ matrix.project }}-${{ steps.project-info.outputs.version }}
          path: ./${{ matrix.project }}/dist/

  qa-tests:
    name: QA Tests
    runs-on: ubuntu-latest
    needs: [build-release, validate-release]

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Run QA smoke tests
        run: |
          echo "üß™ Running QA smoke tests"
          # „Åì„Åì„Å´QA„ÉÜ„Çπ„Éà„ÅÆ„Ç≥„Éû„É≥„Éâ„ÇíËøΩÂä†
          # ‰æã: newman run postman-collection.json

      - name: Performance tests
        run: |
          echo "‚ö° Running performance tests"
          # „Åì„Åì„Å´„Éë„Éï„Ç©„Éº„Éû„É≥„Çπ„ÉÜ„Çπ„Éà„ÅÆ„Ç≥„Éû„É≥„Éâ„ÇíËøΩÂä†
          # ‰æã: k6 run performance-tests.js

  approval-gate:
    name: Approval Gate
    runs-on: ubuntu-latest
    needs: [qa-tests, validate-release]
    if: github.event_name == 'pull_request'
    environment: release-approval

    steps:
      - name: Wait for approval
        run: |
          echo "üö™ Waiting for release approval..."
          echo "This job requires manual approval to proceed with release."

  create-release-notes:
    name: Create Release Notes
    runs-on: ubuntu-latest
    needs: [qa-tests, validate-release]
    if: github.event_name == 'push'

    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Determine project and generate release notes
        id: release-notes
        run: |
          # Extract project and version from branch name
          BRANCH_NAME=${GITHUB_HEAD_REF:-${GITHUB_REF#refs/heads/}}
          if [[ $BRANCH_NAME =~ ^release/([^/]+)/v([0-9]+\.[0-9]+\.[0-9]+)$ ]]; then
            PROJECT=${BASH_REMATCH[1]}
            CURRENT_VERSION=${BASH_REMATCH[2]}
          elif [[ $BRANCH_NAME =~ ^release/v?([0-9]+\.[0-9]+\.[0-9]+)$ ]]; then
            PROJECT="myscheduler"
            CURRENT_VERSION=${BASH_REMATCH[1]}
          fi

          echo "üìù Generating release notes for $PROJECT v$CURRENT_VERSION"

          # ÂâçÂõû„ÅÆ„Çø„Ç∞„ÇíÊ§úÁ¥¢Ôºà„Éó„É≠„Ç∏„Çß„ÇØ„ÉàÂõ∫ÊúâÔºâ
          PREVIOUS_TAG=$(git describe --tags --abbrev=0 --match="$PROJECT/v*" --exclude="$PROJECT/v$CURRENT_VERSION" 2>/dev/null || echo "")

          if [[ -n "$PREVIOUS_TAG" ]]; then
            echo "## üîÑ Changes since $PREVIOUS_TAG" > release-notes.md
            echo "" >> release-notes.md

            # „Éó„É≠„Ç∏„Çß„ÇØ„ÉàÈñ¢ÈÄ£„ÅÆ„Ç≥„Éü„ÉÉ„Éà„ÅÆ„ÅøÊäΩÂá∫
            git log --pretty=format:"- %s (%an)" $PREVIOUS_TAG..HEAD --grep="$PROJECT" -- "$PROJECT/" >> release-notes.md

            # Á©∫„ÅÆÂ†¥Âêà„ÅØÂÖ®„Ç≥„Éü„ÉÉ„Éà„ÇíÂê´„ÇÅ„Çã
            if [[ ! -s release-notes.md || $(wc -l < release-notes.md) -le 2 ]]; then
              echo "## üîÑ Changes since $PREVIOUS_TAG" > release-notes.md
              echo "" >> release-notes.md
              git log --pretty=format:"- %s (%an)" $PREVIOUS_TAG..HEAD >> release-notes.md
            fi
          else
            echo "## üéâ Initial Release of $PROJECT" > release-notes.md
            echo "" >> release-notes.md
            echo "This is the first release of $PROJECT v$CURRENT_VERSION." >> release-notes.md
          fi

          echo "" >> release-notes.md
          echo "---" >> release-notes.md
          echo "ü§ñ Generated with [Claude Code](https://claude.ai/code)" >> release-notes.md

          echo "project=$PROJECT" >> $GITHUB_OUTPUT
          echo "version=$CURRENT_VERSION" >> $GITHUB_OUTPUT

      - name: Upload release notes
        uses: actions/upload-artifact@v4
        with:
          name: release-notes-${{ steps.release-notes.outputs.project }}-v${{ steps.release-notes.outputs.version }}
          path: release-notes.md